import feedparser
import logging
import asyncio
import json
import os
import aiohttp  # 用于异步HTTP请求（替代telegram库）

# 从环境变量读取SafeW配置（替换原Telegram配置）
SAFEW_BOT_TOKEN = os.getenv("SAFEW_BOT_TOKEN")
SAFEW_CHAT_ID = os.getenv("SAFEW_CHAT_ID")
RSS_FEED_URL = os.getenv("RSS_FEED_URL")

# 存储已发送链接的本地文件（注意：GitHub Actions中需改用持久化存储，如Issues）
SENT_LINKS_FILE = "sent_links.json"

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)

# 读取已发送的链接（去重依据）
def load_sent_links():
    try:
        if os.path.exists(SENT_LINKS_FILE):
            with open(SENT_LINKS_FILE, "r", encoding="utf-8") as f:
                content = f.read().strip()
                return json.loads(content) if content else []
        logging.info("首次运行，创建空链接列表")
        return []
    except Exception as e:
        logging.error(f"读取已发送链接失败：{str(e)}")
        return []

# 保存已发送的链接
def save_sent_links(links):
    try:
        with open(SENT_LINKS_FILE, "w", encoding="utf-8") as f:
            json.dump(links, f, ensure_ascii=False, indent=2)
        logging.info(f"已保存链接列表（共{len(links)}条）")
    except Exception as e:
        logging.error(f"保存已发送链接失败：{str(e)}")

# 获取RSS更新
def fetch_rss_updates():
    try:
        logging.info(f"获取RSS源：{RSS_FEED_URL}")
        feed = feedparser.parse(RSS_FEED_URL)
        if feed.bozo:
            logging.error(f"RSS解析错误：{feed.bozo_exception}")
            return None
        logging.info(f"成功获取{len(feed.entries)}条RSS条目")
        return feed
    except Exception as e:
        logging.error(f"获取RSS失败：{str(e)}")
        return None

# 转义Markdown特殊字符（适配SafeW的格式要求）
def escape_markdown(text):
    special_chars = r"_*~`>#+-.!()"
    for char in special_chars:
        text = text.replace(char, f"\{char}")
    return text

# 发送单条消息到SafeW（异步请求）
async def send_to_safew(session, title, link, delay=3):
    try:
        # 发送前等待指定秒数（避免频率限制）
        await asyncio.sleep(delay)
        
        # 构造消息内容（简化格式，避免复杂解析）
        escaped_title = escape_markdown(title)
        escaped_link = escape_markdown(link)
        message = f"🔔 新内容提醒\n\n标题：{escaped_title}\n链接：{escaped_link}"
        logging.info(f"准备发送：{message[:50]}...")
        
        # SafeW API地址（根据实际接口调整）
        api_url = f"https://api.safew.org/bot{SAFEW_BOT_TOKEN}/sendMessage"
        params = {
            "chat_id": SAFEW_CHAT_ID,
            "text": message,
            "parse_mode": "Markdown",  # 按SafeW支持的格式调整
            "disable_web_page_preview": True
        }
        
        # 发送异步POST请求
        async with session.get(api_url, params=params) as response:
            response_text = await response.text()
            logging.info(f"SafeW响应：状态码={response.status}，内容={response_text[:200]}")
            
            if response.status == 200:
                logging.info("消息发送成功")
                return True
            else:
                logging.error(f"发送失败（状态码：{response.status}）")
                return False
    
    except Exception as e:
        logging.error(f"发送过程异常：{str(e)}")
        return False

# 检查更新并推送新内容
async def check_and_push(sent_links):
    rss_feed = fetch_rss_updates()
    if not rss_feed:
        return
    
    new_entries = []
    for entry in rss_feed.entries:
        entry_link = entry.get("link", "")
        if not entry_link:
            logging.warning("跳过无链接的条目")
            continue
        
        # 去重逻辑（基于链接）
        if entry_link not in sent_links:
            new_entries.append({
                "title": entry.get("title", "无标题"),
                "link": entry_link
            })
    
    if new_entries:
        logging.info(f"发现{len(new_entries)}条新内容，准备推送（间隔{3}秒）")
        
        # 异步发送所有新内容
        async with aiohttp.ClientSession() as session:
            success_links = []
            for i, entry in enumerate(new_entries):
                # 第一条立即发送，后续每条间隔3秒
                delay = 3 if i > 0 else 0
                success = await send_to_safew(
                    session,
                    title=entry["title"],
                    link=entry["link"],
                    delay=delay
                )
                if success:
                    success_links.append(entry["link"])
        
        # 保存成功推送的链接（用于去重）
        if success_links:
            sent_links.extend(success_links)
            save_sent_links(sent_links)
    else:
        logging.info("无新内容需要推送")

# 主函数
async def main():
    logging.info("===== SafeW RSS推送脚本启动 =====")
    
    # 校验必要配置
    if not all([SAFEW_BOT_TOKEN, SAFEW_CHAT_ID, RSS_FEED_URL]):
        logging.error("错误：缺失必要环境变量（SAFEW_BOT_TOKEN/SAFEW_CHAT_ID/RSS_FEED_URL）")
        return
    
    # 加载已发送链接
    sent_links = load_sent_links()
    
    try:
        await check_and_push(sent_links)
    except Exception as e:
        logging.error(f"主逻辑执行失败：{str(e)}")
    
    logging.info("===== 脚本运行结束 =====")

if __name__ == "__main__":
    asyncio.run(main())
